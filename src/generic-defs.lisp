(defpackage :cl-gena/generic-defs
  (:use :common-lisp :anaphora :cl-gena/fancy-tools :cl-gena/random)
  (:export #:genotype
           #:population #:size #:genotype-list
           #:fitness
           #:initialize-population
           #:select
           #:crossover
           #:mutate
           #:terminate?))

(in-package :cl-gena/generic-defs)

(defparameter *population-size* 1024)

(defclass genotype ()
  ((fitness :accessor genotype-fitness
            :initarg :fitness
            :initform nil)))

(defclass population ()
  ((genotypes :accessor genotype-list
              :initarg :genotype-list
              :initform nil
              :type list)
   (size :reader size
         :initarg :size)))

(defmacro initialize-population (pop-type generator size)
  `(make-instance
    ',pop-type
    :size ,size
    :genotype-list (loop for i from 1 to ,size collect
                        (funcall ,generator i))))

;; genotype -> number
(defgeneric fitness (g))

(defmethod fitness :around ((g genotype))
  "Memoization"
  (aif (genotype-fitness g)
       it
       (let ((f (call-next-method)))
         (setf (genotype-fitness g) f))))

;; selection stage parameters

;; Note: the next equality must hold
;;          (n ^ 2 + n) * children-per-parents >= 2 * population-size
;;          where n = (elitism-rate + tournament-rate) * population-size (e. g. number of parents)
;;            and childern-per-parents is number of children generated by crossover from one pair
;;       otherwise the size of population will decrease in time
;; that's pretty easy though (to make population of size 1000 decay, (er + tr) should be < 0.032)
(defparameter *elitism-enabled* t)
(defparameter *elitism-rate* 0.1)

(defparameter *tournament-enabled* t)
(defparameter *tournament-t* 2)
(defparameter *tournament-rate* 0.2)

;; population -> population
(defgeneric select (population))

(defmethod select ((p population))
  "Default behaviour performs elitism and tournament"
  (let ((g-list (genotype-list p))
        (selected nil))
    (when *elitism-enabled*
      (let ((elite-size (round (* *elitism-rate*
                                  (size p)))))
        (multiple-value-bind (elite rest)
            (take-n-max elite-size g-list
                        :comparator (lambda (g1 g2)
                                      (compare-number (fitness g1)
                                                      (fitness g2))))
          (setf selected elite)
          (setf g-list rest))))

    (when *tournament-enabled*
      (let ((champions-count (round (* *tournament-rate*
                                       (size p)))))
        (labels ((%take (n lst &optional acc)
                   (if (<= n 0)
                       acc
                       (let ((g (maximum (random-take *tournament-t* lst))))
                         (%take (1- n) (remove g lst) (cons g acc))))))
          (appendf selected (%take champions-count g-list)))))
    
    (when (null selected) (error "No genotype passed the selection stage"))
    selected))

;; genotype -> genotype -> [genotype]
(defgeneric crossover (genotype1 genotype2))

;; genotype -> genotype
(defgeneric mutate (genotype))

(defgeneric terminate? (population))

