(defpackage :cl-gena/generic-defs
  (:use :common-lisp :anaphora :cl-gena/fancy-tools :cl-gena/random)
  (:export #:genotype
           #:population #:size #:genotype-list
           #:fitness
           #:initialize-population
           #:select
           #:crossover
           #:mutate
           #:terminate?))

(in-package :cl-gena/generic-defs)

(defparameter *population-size* 1024)

(defclass genotype ()
  ((fitness :accessor genotype-fitness
            :initarg :fitness
            :initform nil)))

(defclass population ()
  ((genotypes :accessor genotype-list
              :initarg :genotype-list
              :initform nil
              :type list)
   (size :reader size
         :initarg :size)))

(defmacro initialize-population (pop-type generator size)
  `(make-instance
    ',pop-type
    :size ,size
    :genotype-list (loop for i from 1 to ,size collect
                        (funcall ,generator i))))

;; genotype -> number
(defgeneric fitness (g))

(defmethod fitness :around ((g genotype))
  "Memoization"
  (aif (genotype-fitness g)
       it
       (let ((f (call-next-method)))
         (setf (genotype-fitness g) f))))

(defun fitness-comparator (g1 g2)
  (compare-number (fitness g1)
                  (fitness g2)))

;; selection stage parameters

;; Note: the next equality must hold
;;          (n ^ 2 + n) * children-per-parents >= 2 * population-size
;;          where n = (elitism-rate + tournament-rate) * population-size (e. g. number of parents)
;;            and childern-per-parents is number of children generated by crossover from one pair
;;       otherwise the size of population will decrease in time
;; that's pretty easy though (to make population of size 1000 decay, (er + tr) should be < 0.032)
(defparameter *elitism-enabled* t)
(defparameter *elitism-rate* 0.1)

(defparameter *tournament-enabled* t)
(defparameter *tournament-t* 2)
(defparameter *tournament-rate* 0.2)

;; the probabilty that genotype pair will yield children
(defparameter *reproduction-probability* 1.0)

;; population -> [genotype]
(defgeneric select (population))

(defmethod select ((p population))
  "Default behaviour performs elitism and tournament"
  (let ((g-list (genotype-list p))
        elite champions)
    (when *elitism-enabled*
      (let ((elite-size (round (* *elitism-rate*
                                  (size p)))))
        (multiple-value-bind (best rest)
            (take-n-max elite-size g-list
                        :comparator #'fitness-comparator)
          (setf elite best)
          (setf g-list rest))))

    (when *tournament-enabled*
      (let ((champions-count (round (* *tournament-rate*
                                       (size p)))))
        (labels ((%take (n lst &optional acc)
                   (if (<= n 0)
                       acc
                       (let ((g (maximum (random-take *tournament-t* lst)
                                         :comparator #'fitness-comparator)))
                         (%take (1- n) (remove g lst) (cons g acc))))))
          (setf champions (%take champions-count g-list)))))
    
    (when (and (null elite)
               (null champions))
      (error "No genotype passed the selection stage"))
    (values elite champions)))

;; genotype -> genotype -> [genotype]
(defgeneric crossover (genotype1 genotype2))

;; genotype -> genotype
(defgeneric mutate (genotype))

(defgeneric terminate? (population))

;; population -> population
(defun evolve (pop)
  "Performs one iteration of evolution, spawning new population"
  (multiple-value-bind (elite champions) (select pop)
    (let* ((parents (append elite champions))
           (children (loop for p1 in parents append
                          (loop for p2 in parents
                             unless (eq p1 p2)
                             when (probability-check *reproduction-probability*)
                             append (mapcar #'mutate (crossover p1 p2))))))
      (take-n-max (size pop) children :comparator #'fitness-comparator)
      (copy-instance pop :genotype-list children))))

;; population -> population
(defun evolution (pop)
  pop)
